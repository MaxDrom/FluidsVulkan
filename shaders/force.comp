#version 430
//#extension GL_EXT_debug_printf : enable
layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

struct Boid
{
    vec2 pos;
    vec2 vel;
    vec4 col;
};

layout(std430, binding = 0) readonly buffer boidsBufferIn
{
    Boid boids_in[];
};

layout(std430, binding = 1) readonly buffer densityBuffer
{
    float densities[];
};

layout(std430, binding = 2) writeonly buffer boidsBufferOut
{
    Boid boids_out[];
};

layout(binding=3, r32ui) readonly uniform uimage2D prefixSum;

layout(push_constant) uniform PushConstants {
    uint bufferLength;
    float perceptionRadius;
    float delta;
}push;

ivec2 imSize = imageSize(prefixSum);

ivec2 getTexCoords(uint id)
{
    return ivec2(id%imSize.x, id/imSize.x);
}
const uint maxSteps = 1024*1024;
const float PI = radians(180);

vec3 temperatureGradient(float t) {
    t = clamp(t, 0.0, 1.0);

    if (t < 0.25) {
        float nt = t / 0.25;
        return vec3(0.0, nt, 1.0);// blue → cyan
    } else if (t < 0.5) {
        float nt = (t - 0.25) / 0.25;
        return vec3(0.0, 1.0, 1.0 - nt);// cyan → green
    } else if (t < 0.75) {
        float nt = (t - 0.5) / 0.25;
        return vec3(nt, 1.0, 0.0);// green → yellow
    } else {
        float nt = (t - 0.75) / 0.25;
        return vec3(1.0, 1.0 - nt, 0.0);// yellow → red
    }
}

float ViscSmoothFunction(float radius, float dist)
{
    radius = radius*256;
    dist = dist*256;
    float volume = PI*pow(radius, 8)/4;
    float value = max(0, radius*radius - dist*dist);
    return value*value*value/volume;
}
float SmoothFunction(float radius, float dist)
{
    radius = radius*256;
    dist = dist*256;
    float volume = PI*pow(radius, 5)/10;
    float value = max(0, radius - dist);
    return value*value*value/volume;
}

float SmoothFunctionSlope(float radius, float dist)
{
    radius = radius*256;
    dist = dist*256;
    float volume = PI*pow(radius, 5)/10;
    float value = max(0, radius - dist);
    return -3*value*value/volume;
}
const float targetDensity = 10;
const float densityMult = 15;
float Pressure(float density)
{

    float error = (density - targetDensity);
    return error*densityMult;
}
const vec2 blackHolePos = vec2(0.5, 0.5);
vec2 forceToBlackHole(vec2 pos)
{
    vec2 toBlackHole = blackHolePos - pos;
    float d = length(toBlackHole);
    float r = max(length(toBlackHole), 0.01);
    if(d < 0.00001)
        return vec2(0);
    return 0.005*normalize(toBlackHole)/(r*r);
}

void main()
{
    uint id = gl_GlobalInvocationID.x;
    if (id>=push.bufferLength)
    return;

    Boid boid = boids_in[id];
    ivec2 grid_id = ivec2(floor(boid.pos*(imSize-ivec2(1))));

    int y_end = min(grid_id.y+2, imSize.y);
    int y_start = max(grid_id.y-1, 0);
    int x_end = min(grid_id.x+2, imSize.x);
    int x_start = max(grid_id.x-1, 0);

    vec2 force = vec2(0);
    vec2 averageVel = vec2(0);
    for (int y = y_start; y<y_end; y++)
    {
        int x = x_start;
        int it_ind = x+ (y*imSize.x);
        int start_ind = int(imageLoad(prefixSum, getTexCoords(it_ind-1)).r);

        for (x = x_start; x< x_end; x++)
        {
            int end_ind = min(int(imageLoad(prefixSum, ivec2(x, y)).r), int(start_ind + maxSteps));
            for (uint i = start_ind; i< end_ind; i++)
            {
                

                Boid neign = boids_in[i];
                vec2 dist = boid.pos-neign.pos;

                float d = length(dist);

                if (d>=push.perceptionRadius)
                continue;
                averageVel+=ViscSmoothFunction(push.perceptionRadius, d)/densities[i]*(neign.vel-boid.vel);
                if (i == id)
                continue;



                float slope = SmoothFunctionSlope(push.perceptionRadius, d);
                float density = densities[i];
                float p = (Pressure(density) + Pressure(densities[id]))/2;
                if (d>0.00000001)
                {
                    vec2 dir = normalize(dist);
                    force -= p*slope*dir/density;
                }
                else
                force += vec2(sign(id - push.bufferLength/2), 0)*p*slope/density;

            }
            start_ind = end_ind;
        }
    }
    //averageVel += boid.vel;
    force += 300*averageVel*length(averageVel);// - 2*boid.vel*length(boid.vel);
    boid.vel += force/densities[id]*push.delta+forceToBlackHole(boid.pos)*push.delta;
    //boid.col = vec4(temperatureGradient(max(Pressure(densities[id]), 0)/densityMult/5), 1);
    boid.col = vec4(temperatureGradient(4*length(boid.vel)), 1);
    boids_out[id] = boid;
}




