#version 430
//#extension GL_EXT_debug_printf : enable
layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

struct Boid
{
    vec2 pos;
    vec2 vel;
    vec4 col;
};

layout(std430, binding = 1) readonly buffer boidsBufferIn
{
    Boid boids_in[];
};

layout(std430, binding = 0) writeonly buffer boidsBufferOut
{
    Boid boids_out[];
};

layout(binding=2, r32ui) uniform uimage2D bucketSizes;
layout(binding=3, r32ui) readonly uniform uimage2D prefixSum;

layout(push_constant) uniform PushConstants {
    uint bufferLength;
    float alignmentFactor;
    float cohesionFactor;
    float separationFactor;
    float perceptionRadius;
    float maxSpeed;
    float maxForce;
    float delta;
}push;

ivec2 imSize = imageSize(prefixSum);

ivec2 getTexCoords(uint id)
{
    return ivec2(id%imSize.x, id/imSize.x);
}
const uint maxSteps = 1024*1024;

vec2 calculateForceToBlackHole(vec2 pos)
{
    vec2 toBlackHole = vec2(0.5) - pos;
    float r = length(toBlackHole);

    if (r<0.1)
    return 0.001*normalize(toBlackHole)/(0.1*0.1);

    return 0.001*normalize(toBlackHole)/(r*r);
}
void main()
{
    uint id = gl_GlobalInvocationID.x;
    if (id>=push.bufferLength)
    return;

    Boid boid = boids_in[id];
    ivec2 grid_id = ivec2(floor(boid.pos*(imSize-ivec2(1))));
    //debugPrintfEXT("%u", imageLoad(prefixSum,grid_id).r);

    vec2 averagePos = vec2(0);
    vec2 averageVel = vec2(0);
    vec2 averageSep = vec2(0);
    int count = 0;
    float speed = length(boid.vel);
    vec2 velNorm = speed > 0.0001 ? normalize(boid.vel) : vec2(0);

    int y_end = min(grid_id.y+2, imSize.y);
    int y_start = max(grid_id.y-1, 0);
    int x_end = min(grid_id.x+2, imSize.x);
    int x_start = max(grid_id.x-1, 0);

    float sepRadius = push.perceptionRadius*0.3;
    //debugPrintfEXT("%i", start_ind);
    //debugPrintfEXT("%f %f", boid.pos.x, boid.pos.y);
    for (int y = y_start; y<y_end; y++)
    {
        int x = x_start;
        int it_ind = x+ (y*imSize.x);
        int start_ind = int(imageLoad(prefixSum, getTexCoords(it_ind-1)).r);

        for (x = x_start; x< x_end; x++)
        {

            int end_ind = min(int(imageLoad(prefixSum, ivec2(x, y)).r), int(start_ind + maxSteps));
            for (uint i = start_ind; i< end_ind; i++)
            {
                Boid neign = boids_in[i];
                vec2 dist = boid.pos-neign.pos;
                float d = length(dist);
                if (d>=push.perceptionRadius)
                continue;
                if(d>0)
                    averageSep += normalize(dist)/d*0.01;
                
                averagePos+=neign.pos;
                averageVel+=neign.vel;
                count++;
            }
            start_ind = end_ind;
        }
    }
    count--;
    averageVel -= boid.vel;
    averagePos -= boid.pos;
    
    vec2 steer = vec2(0);

    if (count != 0)
    {
        averageVel = averageVel/count;
        averagePos = averagePos/count;
        vec2 alignment = averageVel - boid.vel;

        vec2 cohesion = averagePos- boid.pos;

        vec2 separation= averageSep/count;



        boid.col = vec4(30*push.alignmentFactor*length(alignment), 30*push.cohesionFactor*length(cohesion), 30*push.separationFactor*length(separation), 1.0);

        steer = push.alignmentFactor*alignment+cohesion*push.cohesionFactor+push.separationFactor*separation;//+predForce;


        if (length(steer)>push.maxForce)
        steer = normalize(steer)*push.maxForce;


    }

    
    steer += calculateForceToBlackHole(boid.pos);
    float dt = push.delta;
    
    boid.pos = boid.pos + boid.vel*dt + dt*dt/2*steer;
    boid.vel = boid.vel + steer*dt;
    if (boid.pos.x < 0)
    boid.pos.x = 1 + boid.pos.x;
    if (boid.pos.x > 1)
    boid.pos.x = boid.pos.x - floor(boid.pos.x);

    if (boid.pos.y < 0)
    boid.pos.y = 1 + boid.pos.y;
    if (boid.pos.y > 1)
    boid.pos.y = boid.pos.y - floor(boid.pos.y);
    boid.col += vec4(1);
    boids_out[id] = boid;

}




